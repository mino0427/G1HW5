1조 조원 구성 및 역할

20203043 권수현 - 알고리즘 설계, 발표, 알고리즘 구현, readme 작성

20203058 남태인 - 알고리즘 설계, 알고리즘 구현, 디버깅

20203072 안민호 – readme 작성, 클라이언트 서버 연결, alldefinedlogs

1. 프로그램 구성요소 : server.py, client.py

◆ server.py 구성요소
① 클라이언트 관리
- MAX_CLIENTS: 서버에 연결 가능한 최대 클라이언트 수 = 4
- clients 및 lock: 클라이언트 연결을 관리하는 리스트와 잠금 장치로, 다중 스레드 환경에서 클라이언트 연결 정보를 안전하게 관리

② 메시지 큐
- request_queue: 클라이언트가 보낸 청크 데이터 요청 메시지를 관리하는 큐
- response_queue: 요청에 대한 응답 메시지를 관리하는 큐, 서버가 요청에 맞는 청크 데이터를 전송할 준비가 되었을 때 사용

③ 시스템 클락 관리
- clients_system_clock: 각 클라이언트의 시스템 클락을 저장하여 클라이언트 간 데이터 전송 및 처리 시간을 동기화
- client_message_times: 각 클라이언트별 메시지 처리 시간 설정, 청크 데이터 전송(CHUNK_DATA)과 기타 메시지(OTHER) 처리 시간을 구분
- update_client_clock(): 메시지 유형에 따라 클라이언트 시스템 클락 증가시키는 함수, 특정 메시지 처리 시간 누적하여 클락 업데이트
- sync_with_max_client_time(): 모든 클라이언트의 시스템 클락을 가장 큰 클락 값으로 동기화하여 동기적인 통신 보장

④ 클라이언트 요청 및 응답 처리 - handle_client()
- 각 클라이언트 연결에 대해 별도의 스레드를 통해 실행, 클라이언트가 보내는 요청 및 응답 처리
- 요청 처리: request_queue에서 요청 메시지를 가져와 필요한 클라이언트에게 요청 전달. 클라이언트 간 데이터 요청 순서를 관리, 시스템 클락 업데이트 및 동기화
- 응답 처리: response_queue에서 응답 메시지를 가져와 요청한 클라이언트에게 청크 데이터를 전달. 메시지 처리 후 시스템 클락 업데이트
- 데이터 수신 및 버퍼 관리: 클라이언트로부터 데이터 수신하여 버퍼에 저장.
<END>나 <EoH> 구분자를 기준으로 메시지를 파싱하여 요청/응답으로 처리

⑤ 서버 실행 및 종료 관리 - start_server()
- 서버 설정, 클라이언트 연결. 각 클라이언트마다 새로운 스레드 생성하여 handle_client() 함수 실행
- 클라이언트 ID 할당: 클라이언트 연결 순서에 따라 고유한 FLAG 메시지 전송, 클라이언트 식별
- 로그 파일 생성: 서버 로그 파일을 생성하여 각 클라이언트 통신 및 상태 기록
- 스레드 종료 대기 및 서버 종료(Gracefully Termination): 모든 클라이언트 스레드가 종료될 때까지 대기, 모든 클라이언트 종료 시 서버를 안전하게 종료

◆ client.py 구성요소
① 시스템 클락 및 메시지 처리 시간 관리
- clients_system_clock: 클라이언트별 시스템 클락을 저장하는 딕셔너리.
클라이언트 메시지 처리 시간이 누적되어 동기화 활용
-client_message_times: 클라이언트별 메시지 처리 시간 설정 딕셔너리
청크 데이터 전송과 기타 메시지에 따른 처리 시간 설정
- increment_client_clock(): 클라이언트 메시지 처리 시간 누적하여 클락 업데이트
메시지 유형에 따라 처리 시간을 증가시키고, 증가된 클락 값 반환
- sync_client_clock(): 클라이언트 클락을 특정 값으로 동기화하는 함수
다른 클라이언트와의 통신 중 받은 클락 값을 기준으로 클락 설정

② 파일 분할 및 청크 관리
- split_file_into_chunks(): 지정된 파일을 청크 단위로 분할하여 청크 리스트로 저장하는 함수, 파일을 열어 (청크)128KB씩 나누고, 각 청크를 리스트에 저장하여 반환
- received_chunks: 클라이언트가 전송받은 청크를 저장하는 딕셔너리
클라이언트가 보유하지 않은 파일에 대해 다른 클라이언트로부터 청크를 받아 저장
- all_chunks_received(): 클라이언트가 모든 파일의 청크 수신했는지 확인하는 함수
모든 청크가 수신되면 True를 반환하여 클라이언트 종료 조건을 충족

③ 클라이언트와 서버 간 통신
▷ start_client(): 클라이언트가 서버에 연결, 필요한 파일을 청크 단위로 나눠 전송 및 요청하는 함수
- 클라이언트 ID 및 로그 설정: 서버에서 고유 ID를 받아 클라이언트 식별
클라이언트 로그 파일 생성 및 작업 기록 저장
- 순회 요청: 미보유 파일 청크를 다른 클라이언트로부터 요청하기 위해 순회 방식 설정하여 파일 요청
- 요청 전송: 특정 순서에 맞춰 다른 클라이언트로부터 청크 요청, 청크 ID와 클락 값을 포함한 요청 메시지 전송
- 응답 수신 및 청크 저장: 서버로부터 받은 응답 메시지에서 청크 데이터를 파싱하여 received_chunks에 저장
- 동기화: 수신된 메시지 클락 값 기준으로 클라이언트 클락 동기화

④ 파일 합치기 및 저장
- 모든 파일 청크를 수신하여 완성된 경우, received_chunks에 저장된 청크를 합쳐서 완성된 파일로 저장(complete_file)
- 저장 경로와 파일 이름은 클라이언트 ID 및 전송받은 파일의 ID를 기준으로 지정



2. 소스코드 컴파일 방법 (GCP 사용)

① 구글 클라우드에 접속하여 VM instance를 생성한다.
	지역 : us-central1로 설정
	머신 유형 : e2-micro
	부팅 디스크 : Debian

② 방화벽 규칙을 추가한다
	대상 : 모든 인스턴스 선택
	소스 IP 범위 : 0.0.0.0/0  (모든 IP 주소 허용)
	프로토콜 및 포트 : TCP와 해당 포트를 지정 (port : 9999)

③ 생성된 인스턴스의 SSH를 실행한다.

④ Python과 개발 도구의 패키지들을 설치한다 (Debian 기준)
	sudo apt update
	sudo apt install python3
	sudo apt install python3-pip
	pip install numpy
	pip install numpy scipy
	pip install loguru //Python에서 로그(logging)기능을 제공하는 라이브러리

⑤ 가상환경을 생성하고 활성화한다.
	python3 -m venv myenv(가상환경 이름)
	source myenv/bin/activate //가상환경 활성화

⑥ UPLOAD FILE을 클릭하여 server.py를 업로드한다.
	server.py가 업로드된 디렉터리에서 python3 server.py로 server를 실행한다.

⑦ 로컬에서 powershell 터미널 4개를 열어 python3 client.py로 client 4개를 실행한다. (vscode 터미널에서 실행해도 됨)
	
⑧ server에 4개의 client가 모두 연결되면 프로그램이 실행된다.

☆주의할 점 : server와 client의 host 정의가 자신이 사용하는 외부주소로 되어있는지 확인한다
- 서버: def start_server(host="127.0.0.1", port=9999)에서 host 값
- 클라이언트: def start_client(host="127.0.0.1", port=9999)에서 host 값


3. 프로그램 실행환경 및 실행방법 설명
(실행방법 - 2번 참고)
외부 서버 - 구글 클라우드 (파이썬 3.11.2버전, 0.25-2 vCPU (1 shared core)
		메모리 1GB, Boot disk size 20GB, interface type: SCSI
로컬 실행 환경 - 프로세서 12th Gen Intel(R) Core(TM) i5-12500H 2.50 GHz
		      RAM 16GB, 64bit 운영체제, x64기반 프로세서


4. 구현한 최적의 알고리즘 제시 및 설명

⦁ 알고리즘 시나리오
① [Client] request_order[]을 기반으로 서버에 요청 메시지 전송(REQUEST_CHUNK)
	request_order = [
        {'A': 'B', 'B': 'C', 'C': 'D', 'D': 'A'},
        {'A': 'C', 'B': 'D', 'C': 'A', 'D': 'B'},
        {'A': 'D', 'B': 'A', 'C': 'B', 'D': 'C'}
    ]
② [Server] 클라이언트로부터 "REQUEST_CHUNK"를 받고 저장. A, B, C, D 클라이언트의 각각의 4개의 요청이 Q에 차면 요청 위치에 맞게 4개의 클라이언트로 전송
+ ex) A파일 청크면 A클라이언트(클라이언트1)에게 요청 <- 해당 파일 청크는 해당 클라이언트에게 요청
③ [Client] 서버로부터 요청 수신 및 요청에 맞는 데이터 전송 (REQUEST_CHUNK)
④ [Server] 클라이언트로부터 "CHUNK_DATA"를 받고 저장. A, B, C, D,에서 보낸 4개의 CHUNK가 Q에 차면 위치에 맞게 4개의 클라이언트로 전송
⑤ [Client] 서버로부터 요청한 데이터 수신 및 received_chunks에 저장
⑥ [Client] all_chunks_received()로 chunk가 3907개가 다 모였는지 확인하고 합치기.


5. Error or Additional Message Handling
▶ Additional Message Handling
⊙ Server
① 요청 메시지 처리 (REQUEST_CHUNK)
- 클라이언트가 보낸 청크 요청 메시지를 request_queue에 저장, 필요 시 시스템 클락 업데이트 (클라이언트 요청 순서 맞춤)
- 서버는 request_queue에 데이터 4개가 모이면 해당 요청을 순차적으로 처리, 요청 메시지를 받은 클라이언트에게 요청 내용 전달

② 응답 메시지 처리(CHUNK_DATA)
- 클라이언트로부터 청크 데이터가 포함된 응답 메시지를 response_queue에 저장
요청한 클라이언트에게 해당 청크 전달
- 응답 메시지가 response_queue에 4개가 모이면 순차적으로 처리
청크 데이터를 요청한 클라이언트에게 전송

③ 버퍼 처리 및 메시지 구분자 (<END>, <EoH>)
- 클라이언트로부터 받은 데이터를 버퍼에 저장
<END>, <EoH> 구분자가 나올 때까지 데이터 수신
구분자가 포함된 메시지 발견 시 메시지를 파싱하여 요청이나 응답으로 처리

⊙ Client
① 청크 요청 메시지 전송(REQUEST_CHUNK)
- 클라이언트는 필요할 때마다 다른 클라이언트로부터 특정 청크를 요청하기 위해 REQUEST_CHUNK 메시지를 서버에 전송
- 요청 시: 클라이언트 시스템 클락 업데이트 및 요청 메시지에 현재 클락 값을 추가하여 메시지 전송
- 요청 순서: request_order 리스트에 기반, 순회 순서에 따라 대상 클라이언트에게 청크 요청 반복

② 청크 요청 메시지 수신 및 응답 전송(CHUNK_DATA)
- 다른 클라이언트가 보낸 청크 요청 메시지를 수신 시, 클라이언트는 요청된 청크를 서버를 통해 해당 클라이언트에게 전송
- 청크 데이터는 CHUNK_DATA 메시지 형식으로 전송, 헤더에 필요한 정보와 현재 클락 값을 포함하여 서버에 전달

③ 청크 데이터 수신(SEND_CHUNK)
- 요청한 청크 데이터 수신 시, 메시지 파싱 및 데이터 추출 후 received_chunks에 저장
- 수신한 청크 클락 값을 기준으로 클라이언트 시스템 클락을 동기화하여 일관성 유지



▶ Error Handling (Exception 처리 포함)

⊙ Server
① 데이터 수신 오류
- 클라이언트로부터 데이터를 수신할 때, 데이터가 비어있거나 잘못된 경우 처리,
프로그램 중단 방지
- 데이터가 비정상적인 경우, 로그 파일에 기록, 데이터 수신 중단하거나 다음 수신을 기다림

② 연결 해제 오류(ConnectionResetError)
- 클라이언트와의 연결이 비정상적으로 종료되었을 때 발생
ConnectionResetError 처리 및 해당 클라이언트와 연결을 안전하게 종료하고, clients 리스트에서 제거
- 에러 발생 시 메시지 출력, 로그 파일에 기록

③ 예외 발생 시 서버 종료 처리
- 서버 실행 중 키보드 인터럽트 발생 시 서버 안전 종료를 위한 예외처리
- 모든 클라이언트 소켓을 닫고 로그에 서버 종료 상태 기록 후 서버 종료

⊙ Client
① 파일 관련 에러(파일이 없거나 접근 불가 - FileNotFoundError)
- 청크 생성을 위해 파일을 읽을 때 FileNotFoundError 발생 가능, 오류 메시지 출력, 로그 파일에 기록 및 원인 파악 유도
일반적인 예외 추가 처리, 예상치 못한 파일 접근 오류 포괄적 관리

② 데이터 수신 오류
- 서버로부터 데이터 수신 시, 데이터가 비어 있거나 올바르지 않은 경우 처리
클라이언트가 비정상적으로 종료되는 것 방지
- 수신된 데이터가 없으면 로그파일에 기록, 연결을 계속 유지, 다음 수신 기다림


6. Additional Comments (팀플 날짜 기록)
2024/11/6
과제 시작

11/9
초기 파일 세팅

11/10~/11/13
서버 및 클라이언트 코딩
알고리즘 구상 및 적용
로그 생성
시스템 클락 생성

