▶server.py (서버 코드)
<연결 관련 메시지>
1. [연결됨] 클라이언트 {client_address} (ID: {client_id})
- 클라이언트가 서버에 연결됐을 때 출력, 연결된 클라이언트 주소, ID 기록
2. [서버] 클라이언트 {client_id}에게 FLAG 전송 완료
- 서버가 클라이언트에 고유 FLAG 메시지를 전송하고 나서 출력, 각 클라이언트가 고유 ID 수신 알림
3. [연결 종료] 클라이언트 {client_address} 연결 종료
- 클라이언트가 비정상적으로 연결을 종료했을 때 출력되며, 연결이 끊긴 클라이언트의 주소 표시
4. [연결 종료] 클라이언트 {client_id} 연결 제거 완료
- 클라이언트가 연결을 종료하면, 해당 클라이언트를 서버의 클라이언트 리스트에서 제거

<시스템 클락 관련 메시지>
1. [서버] 클라이언트 시스템 클락 동기화
- sync_with_max_client_time() 함수 호출로 클라이언트 시스템 클락 동기화
- 모든 클라이언트가 동일한 클락 값을 가지도록 설정

<메시지 큐 관련 메시지>
1. [서버] 클라이언트 {target_client_id}에게 요청 메시지 전달: {request_msg}
- REQUEST_CHUNK 메시지를 request_queue에서 꺼내 클라이언트에게 전달
- 요청을 전달받은 클라이언트 ID와 요청 메시지 내용이 포함
2. [서버] 클라이언트 {req_client_id}에게 청크 전송: CHUNK_ID {sender_client_id}:{chunk_id}
- SEND_CHUNK 메시지를 response_queue에서 꺼내 요청 클라이언트에게 청크 데이터를 전송
- 요청을 전달받은 클라이언트 ID와 청크 전송자 ID, 청크 ID가 포함

☆ REQUEST_CHUNK 메시지
1. [서버] 요청 수신: {message}
- 클라이언트로부터 REQUEST_CHUNK 메시지를 수신
2. [서버] 클라이언트 {target_client_id}에게 요청 메시지 전달: {request_msg}
- request_queue에서 REQUEST_CHUNK 메시지를 꺼내 대상 클라이언트에게 전송

☆ SEND_CHUNK 메시지
1. [서버] {sender_client_id}로부터 데이터 수신: {message}
- 클라이언트로부터 SEND_CHUNK 메시지(청크 데이터)를 수신
2. [서버] 클라이언트 {req_client_id}에게 청크 전송: CHUNK_ID {sender_client_id}:{chunk_id}
- response_queue에서 SEND_CHUNK 메시지를 꺼내 요청 클라이언트에게 청크 데이터를 전송

<서버 종료 및 에러 메시지>
1. [서버 에러]에러 발생 종료 작업을 실행합니다.
- 서버가 키보드 인터럽트 또는 예기치 않은 종료 요청을 받았을 때, 안전하게 종료 작업을 실행하고 기록
2. [서버 종료] 서버가 종료됩니다.
- 서버가 정상적으로 종료될 때 마지막으로 기록하는 메시지

▶client.py (클라이언트 코드)
<연결 및 ID 설정>
1. [서버 연결] {host}:{port}에 연결됨.
- 서버에 연결되었음을 나타내며, 연결된 서버의 호스트와 포트를 기록
2. [클라이언트 ID 설정] ID: {client_id}
- 서버로부터 받은 플래그를 통해 클라이언트의 ID가 설정 알림
- 클라이언트는 이 ID를 기반으로 통신을 수행
3. [로그 시작] 클라이언트 {client_num} 로그 파일
- 클라이언트가 시작되고 로그 파일이 열리면 기록되며, 클라이언트 번호가 포함

<파일 선택 및 청크 생성>
1. [파일 선택] {output_file_path}
- 클라이언트가 전송할 파일 경로를 설정
- 경로는 각 클라이언트에 맞는 파일을 선택하도록 설정
2. [진행 중] 청크 단위를 나누는 중...
- 파일을 청크 단위로 나누기 시작
3. [진행 중] 청크 ID {chunk_id} 생성 완료
- 청크가 생성될 때마다 해당 청크의 ID를 기록
4. [완료] 청크 단위로 파일을 나누는 작업이 완료되었습니다.
- 모든 청크가 생성되면 완료 메시지를 기록
5. [청크 생성 완료] 총 {total_chunks}개의 청크 생성
- 전체 청크 개수를 기록. 청크 생성되지 않았을 시, 오류 메시지가 출력

<청크 요청 및 응답 처리>
1. {clock}[청크 요청] 클라이언트 {target_client_id}에게 청크 ID {chunk_index} 요청
- 다른 클라이언트로부터 특정 청크 ID를 요청
- 요청을 보낸 시점의 시스템 클락 값도 함께 출력
2. {clock}[요청 수신] 클라이언트 {req_client_id}의 청크 요청 수신: CHUNK_ID {client_id}:{chunk_index}
- 서버로부터 다른 클라이언트의 청크 요청 수신 알림
- 요청을 수신한 클라이언트와 청크 ID, 수신 당시의 클락 값이 포함
3. {clock}[청크 전송] 클라이언트 {client_id}가 청크 ID {chunk_index} 전송 완료
- 요청된 청크 데이터를 서버를 통해 상대 클라이언트에게 전송할 때 기록
- 전송 시점의 클락 값이 함께 출력
4. data가 아닌 무언가가 들어옴<END>
- 수신된 데이터가 잘못되었을 경우
5. {clock}[청크 수신] 클라이언트{client_id}가 {sender_client_id}로부터 청크 ID {chunk_index} 수신 및 저장
- 클라이언트가 요청한 청크를 서버를 통해 수신
- 수신 클라이언트 ID와 전송한 클라이언트 ID, 청크 ID, 수신 당시의 클락 값 포함

<파일 저장 및 완료 메시지>
1. {clock}[완료] 클라이언트 {client_id}는 모든 파일의 청크를 보유하고 있으므로 연결을 종료합니다.
- 모든 청크를 수신하고 파일 전송이 완료되면 기록
- 클라이언트가 종료될 시점의 클락 값이 포함
2. {clock}[파일 생성 완료] {output_file_path}에 파일이 저장되었습니다.
- 모든 청크를 결합하여 완성된 파일을 저장한 후, 저장된 파일의 경로와 저장 시점의 클락 값을 기록

<MD5 해시 계산 결과>
{file_path}: {md5_hash}
- 파일 전송 후 각 파일의 무결성을 확인하기 위해 MD5 해시 값을 계산한 후 기록
- 파일 경로와 해시 값이 출력되며, 파일이 없거나 접근이 불가능한 경우 해당 파일에 대한 오류 메시지가 기록